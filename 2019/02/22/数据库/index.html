<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>数据库 - Hexo</title><meta description="数据库架构数据库架构可以分为存储文件系统和程序实例两大块，而程序实例根据不同的功能又可以分为如下小模块。  索引模块常见的问题有：  为什么要使用索引 什么样的信息能成为索引 索引的数据结构 密集索引和稀疏索引的区别  为什么要使用索引使用索引就像查字典一样，可以快速查询数据 什么样的信息能成为索引主键、唯一键以及普通键等 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立 B"><meta property="og:type" content="blog"><meta property="og:title" content="数据库"><meta property="og:url" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="数据库架构数据库架构可以分为存储文件系统和程序实例两大块，而程序实例根据不同的功能又可以分为如下小模块。  索引模块常见的问题有：  为什么要使用索引 什么样的信息能成为索引 索引的数据结构 密集索引和稀疏索引的区别  为什么要使用索引使用索引就像查字典一样，可以快速查询数据 什么样的信息能成为索引主键、唯一键以及普通键等 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立 B"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550644570798.png"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C84ea509fa091a10add4e7614e6cb37db"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C259d196856a231aff5e3cf1505848af4"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C20190107191452541898.png"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550731169166.png"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C26a7c9df-22f6-4df4-845a-745c053ab2e5.jpg"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5Cbab0fba6-38e4-45f7-b34d-3edaad43810f.jpg"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C43bf0957-0386-4c09-9ad7-e163c5b62559.jpg"><meta property="og:image" content="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C2959e455-e6cb-4461-aeb3-e319fe5c41db.jpg"><meta property="article:published_time" content="2019-02-22T15:59:59.000Z"><meta property="article:modified_time" content="2020-08-21T12:42:19.215Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="数据库"><meta property="article:tag" content="MySQL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550644570798.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/"},"headline":"Hexo","image":["http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550644570798.png","http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C20190107191452541898.png","http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550731169166.png","http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C26a7c9df-22f6-4df4-845a-745c053ab2e5.jpg","http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5Cbab0fba6-38e4-45f7-b34d-3edaad43810f.jpg","http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C43bf0957-0386-4c09-9ad7-e163c5b62559.jpg","http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%5C2959e455-e6cb-4461-aeb3-e319fe5c41db.jpg"],"datePublished":"2019-02-22T15:59:59.000Z","dateModified":"2020-08-21T12:42:19.215Z","author":{"@type":"Person","name":"John Doe"},"description":"数据库架构数据库架构可以分为存储文件系统和程序实例两大块，而程序实例根据不同的功能又可以分为如下小模块。  索引模块常见的问题有：  为什么要使用索引 什么样的信息能成为索引 索引的数据结构 密集索引和稀疏索引的区别  为什么要使用索引使用索引就像查字典一样，可以快速查询数据 什么样的信息能成为索引主键、唯一键以及普通键等 索引的数据结构 生成索引，建立二叉查找树进行二分查找 生成索引，建立 B"}</script><link rel="canonical" href="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-02-22T15:59:59.000Z" title="2019-02-22T15:59:59.000Z">2019-02-22</time><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">33 minutes read (About 4928 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">数据库</h1><div class="content"><h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><p>数据库架构可以分为存储文件系统和程序实例两大块，而程序实例根据不同的功能又可以分为如下小模块。</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550644570798.png" alt="1550644570798"></p>
<h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><p>常见的问题有：</p>
<ul>
<li>为什么要使用索引</li>
<li>什么样的信息能成为索引</li>
<li>索引的数据结构</li>
<li>密集索引和稀疏索引的区别</li>
</ul>
<h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><p>使用索引就像查字典一样，可以快速查询数据</p>
<h3 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h3><p>主键、唯一键以及普通键等</p>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><ul>
<li>生成索引，建立二叉查找树进行二分查找</li>
<li>生成索引，建立 B Tree 结构结构进行查找</li>
<li>生成索引，建立 B+ Tree 结构进行查找</li>
<li>生成索引，建立 Hash 结构进行查找</li>
</ul>
<h4 id="什么是-B-Tree-索引？"><a href="#什么是-B-Tree-索引？" class="headerlink" title=" 什么是 B Tree 索引？"></a> 什么是 B Tree 索引？</h4><p>B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。因此在讲 B-Tree 之前先了解下磁盘的相关知识。</p>
<ul>
<li><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
</li>
<li><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K ，在 MySQL 中可通过如下命令查看页的大小：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_page_size&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p>
</li>
</ul>
<p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p>一棵 m 阶的 B-Tree 有如下特性：</p>
<ul>
<li>每个节点最多有 m 个孩子<ul>
<li>除了根节点和叶子节点外，其它每个节点至少有 Ceil(m/2) 个孩子</li>
<li>若根节点不是叶子节点，则至少有 2 个孩子</li>
</ul>
</li>
<li>所有叶子节点都在同一层，且不包含其它关键字信息</li>
<li>每个非叶子节点包含 n 个关键字信息（P0,P1,…Pn, k1,…kn）<ul>
<li>关键字的个数 n 满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li>
<li>ki(i=1,…n) 为关键字，且关键字升序排序</li>
<li>Pi(i=0,…n) 为指向子树根节点的指针。P(i-1) 指向的子树的所有节点关键字均小于 ki ，但都大于 k(i-1) </li>
</ul>
</li>
</ul>
<p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C84ea509fa091a10add4e7614e6cb37db" alt="B-Tree 的结构"></p>
<ul>
<li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，point 存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域，对应三个 point 指向的子树的数据的范围域。</li>
<li>以根节点为例，key 为 17 和 35 ，P1 指针指向的子树的数据范围为小于 17 ，P2 指针指向的子树的数据范围为 [17~35] ，P3 指针指向的子树的数据范围为大于 35 。</li>
</ul>
<p>模拟查找 key 为 29 的过程：</p>
<ul>
<li>1、根据根节点找到磁盘块 1 ，读入内存。【磁盘I/O操作第1次】</li>
<li>2、比较 key 29 在区间（17,35），找到磁盘块 1 的指针 P2 。</li>
<li>3、根据 P2 指针找到磁盘块 3 ，读入内存。【磁盘I/O操作第2次】</li>
<li>4、比较 key 29 在区间（26,30），找到磁盘块3的指针P2。</li>
<li>5、根据 P2 指针找到磁盘块 8 ，读入内存。【磁盘I/O操作第3次】</li>
<li>6、在磁盘块 8 中的 key 列表中找到 eky 29 。</li>
</ul>
<p>分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<h4 id="什么是-B-Tree-索引？-1"><a href="#什么是-B-Tree-索引？-1" class="headerlink" title="什么是 B+Tree 索引？"></a>什么是 B+Tree 索引？</h4><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。</p>
<p>从上一节中的 B-Tree 结构图中可以看到，每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p>
<p>B+Tree 相对于 B-Tree 有几点不同：</p>
<ul>
<li>非叶子节点只存储键值信息。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
</ul>
<p><strong>B+ Tree 更适合用来做存储索引</strong>：</p>
<ul>
<li>B+ 数的磁盘读写代价更低</li>
<li>B+ 数的查询效率更加稳定</li>
<li>B+ 数更有利于对数据库的扫描（范围查询）</li>
</ul>
<p>将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C259d196856a231aff5e3cf1505848af4" alt="B+Tree 的结构"></p>
<blockquote>
<p>磁盘块4中的10数据，画错了，范围在[K[i], K[i+1])，左闭右开</p>
</blockquote>
<ul>
<li>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li>
</ul>
<p>可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：</p>
<ul>
<li>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 <em>10^3</em> 10^3 = 10亿 条记录。</li>
<li>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2<del>4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1</del>3 次磁盘 I/O 操作。</li>
</ul>
<h4 id="什么是-hash-索引？"><a href="#什么是-hash-索引？" class="headerlink" title="什么是 hash 索引？"></a>什么是 hash 索引？</h4><p>基于哈希表实现，优点是查找非常快。如下图 ：</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C20190107191452541898.png" alt="20190107191452541898"></p>
<p>哈希索引就是采用一定的哈希算法，将键值换算成新的哈希值，检索时不需要想B+Tree那样从根结点开始查找，而是经过计算直接定位，所以速度很快。</p>
<p>但是也有限制：</p>
<ul>
<li>只支持精确查找，不能用于部分查找和范围查找。无法排序和分组。因为原来有序的键值经过哈希算法很可能打乱。</li>
<li>如果哈希冲突很多，查找速度很慢。比如在有大量重复键值的情况下。</li>
<li>不能利用部分索引查询</li>
<li>不能</li>
</ul>
<h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C1550731169166.png" alt="1550731169166"></p>
<h3 id="MyISAM-索引与-InnoDB-索引的区别？"><a href="#MyISAM-索引与-InnoDB-索引的区别？" class="headerlink" title="MyISAM 索引与 InnoDB 索引的区别？"></a>MyISAM 索引与 InnoDB 索引的区别？</h3><ul>
<li>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。</li>
<li>InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效</li>
</ul>
<h3 id="如何定位并优化慢查询的-Sql"><a href="#如何定位并优化慢查询的-Sql" class="headerlink" title="如何定位并优化慢查询的 Sql"></a>如何定位并优化慢查询的 Sql</h3><p>需要具体场景具体分析，其大致思路</p>
<ul>
<li>根据慢日志定位到慢查询的 sql</li>
<li>使用 explain 等工具分析 sql</li>
<li>修改 sql 或者尽量让 sql 走索引</li>
</ul>
<h4 id="定位慢查询sql"><a href="#定位慢查询sql" class="headerlink" title="定位慢查询sql"></a>定位慢查询sql</h4><p>开启慢查询日志即可 </p>
<p>文件方式配置 MySQL 慢查询的方法：</p>
<ul>
<li>查询 MySQL 慢查询状态的方法： </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%query%&#x27;</span>;   </span><br></pre></td></tr></table></figure>

<ul>
<li>在 mysql 配置文件 my.cnf 中增加： </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">log-slow-queries=/opt/data/slowquery.log</span><br><span class="line">long_query_time=2 </span><br><span class="line">log-queries-not-using-indexes  </span><br></pre></td></tr></table></figure>

<ul>
<li>命令方式配置 MySQL 慢查询的方法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="keyword">on</span>; </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file=‘/opt/<span class="keyword">data</span>/slow_query.log’;  </span><br></pre></td></tr></table></figure>

<ul>
<li>解析 MySQL 慢查询日志的方法，按照 sql 执行时间最长的前 20 条 sql：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldumpslow -s t -t 20 -g &#39;select&#39; &#x2F;opt&#x2F;data&#x2F;slowquery.log </span><br></pre></td></tr></table></figure>

<p>在 log 中就能找到慢查询的 sql。</p>
<h4 id="Explian-关键字"><a href="#Explian-关键字" class="headerlink" title="Explian 关键字"></a>Explian 关键字</h4><ul>
<li><p>Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。</p>
<p>Explain语法：explain select … from … [where …]</p>
<p>例如：explain select * from news;</p>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+------</span><br><span class="line">| id | select_type | table | type  | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+------</span><br></pre></td></tr></table></figure>

<p>下面对各个属性进行了解：</p>
<p>1、id：这是SELECT的查询序列号</p>
<p>2、select_type：select_type就是select的类型，可以有以下几种：</p>
<blockquote>
<p>SIMPLE：简单SELECT(不使用UNION或子查询等)</p>
<p>PRIMARY：最外面的SELECT</p>
<p>UNION：UNION中的第二个或后面的SELECT语句</p>
<p>DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询</p>
<p>UNION RESULT：UNION的结果。</p>
<p>SUBQUERY：子查询中的第一个SELECT</p>
<p>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询</p>
<p>DERIVED：导出表的SELECT(FROM子句的子查询)</p>
</blockquote>
<p>3、table：显示这一行的数据是关于哪张表的</p>
<p>4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。</p>
<blockquote>
<p>结果值从好到坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p>
</blockquote>
<p>5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行</p>
<p>6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL</p>
<p>7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好</p>
<p>8、ref：显示使用哪个列或常数与key一起从表中选择行。</p>
<p>9、rows：显示MySQL认为它执行查询时必须检查的行数。</p>
<p>10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。</p>
<blockquote>
<p>Distinct<br>一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p>
<p>Not exists<br>MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，</p>
<p>就不再搜索了</p>
<p>Range checked for each</p>
<p>Record（index map:#）<br>没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p>
<p>Using filesort<br>看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行</p>
<p>Using index<br>列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候</p>
<p>Using temporary<br>看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p>
<p>Using where<br>使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题</p>
</blockquote>
<p>其他一些Tip：</p>
<p>当type 显示为 “index” 时，并且Extra显示为 “Using Index”， 表明使用了覆盖索引。</p>
</li>
</ul>
<h3 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h3><p>看看如下博客即可</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b7911e0394b0">联合索引的最左前缀匹配原则</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/36996520/answer/93256153">mysql索引最左匹配原则的理解?</a></li>
</ul>
<h3 id="索引是建立得越多越好的吗"><a href="#索引是建立得越多越好的吗" class="headerlink" title="索引是建立得越多越好的吗"></a>索引是建立得越多越好的吗</h3><ul>
<li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li>
<li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li>
<li>更多的索引意味着也需要更多的空间</li>
</ul>
<h2 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>MyISAM 与 InnoDB 关于锁方面的区别是什么</li>
<li>数据库事务的四大特性</li>
<li>事务隔离级别以及各级别下的并发访问问题</li>
<li>InnoDB 可重复读隔离级别下如何避免幻读</li>
<li>RC、RR 级别下的 InnoDB 的非堵塞如果实现</li>
</ul>
<h3 id="MyISAM-与-InnoDB-关于锁方面的区别是什么"><a href="#MyISAM-与-InnoDB-关于锁方面的区别是什么" class="headerlink" title="MyISAM 与 InnoDB 关于锁方面的区别是什么"></a>MyISAM 与 InnoDB 关于锁方面的区别是什么</h3><ul>
<li>MyISAM 默认用的是表级锁，不支持行级锁</li>
<li>InnoDB 默认用的是行级锁，也支持表级锁</li>
</ul>
<h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul>
<li>按锁的粒度划分，可分为表级锁、行级锁和页级锁</li>
<li>按锁的级别划分，可分为共享锁和排他锁</li>
<li>按加锁的方式划分，可分为自动锁和显示锁</li>
<li>按操作划分，可分为 DML 锁和 DDL 锁</li>
<li>按使用方式划分，可分为乐观锁和悲观锁</li>
</ul>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h4 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>
<h4 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h4 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>使用重做日志来保证持久性。</p>
<h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C26a7c9df-22f6-4df4-845a-745c053ab2e5.jpg" alt="26a7c9df-22f6-4df4-845a-745c053ab2e5"></p>
<h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h4><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5Cbab0fba6-38e4-45f7-b34d-3edaad43810f.jpg" alt="bab0fba6-38e4-45f7-b34d-3edaad43810f"></p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C43bf0957-0386-4c09-9ad7-e163c5b62559.jpg" alt="43bf0957-0386-4c09-9ad7-e163c5b62559"></p>
<h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h4><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="%E6%95%B0%E6%8D%AE%E5%BA%93%5C2959e455-e6cb-4461-aeb3-e319fe5c41db.jpg" alt="2959e455-e6cb-4461-aeb3-e319fe5c41db"></p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h4><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h4 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h4><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h4 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h4><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p>
<h4 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h4><p>强制事务串行执行。</p>
<hr>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻影读</th>
<th align="center">加锁读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">提交读</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md">数据库系统原理 </a></li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="link-muted mr-2" rel="tag" href="/tags/MySQL/">MySQL</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" href="/" style="background-color:rgba(255,128,62,.87);border-color:transparent;color:white;" target="_blank" rel="noopener"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a><a class="button is-danger donate" href="/" target="_blank" rel="noopener"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/02/23/Redis/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Redis</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-item">计算机网络</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#数据库架构"><span class="mr-2">1</span><span>数据库架构</span></a></li><li><a class="is-flex" href="#索引模块"><span class="mr-2">2</span><span>索引模块</span></a><ul class="menu-list"><li><a class="is-flex" href="#为什么要使用索引"><span class="mr-2">2.1</span><span>为什么要使用索引</span></a></li><li><a class="is-flex" href="#什么样的信息能成为索引"><span class="mr-2">2.2</span><span>什么样的信息能成为索引</span></a></li><li><a class="is-flex" href="#索引的数据结构"><span class="mr-2">2.3</span><span>索引的数据结构</span></a><ul class="menu-list"><li><a class="is-flex" href="#什么是-B-Tree-索引？"><span class="mr-2">2.3.1</span><span> 什么是 B Tree 索引？</span></a></li><li><a class="is-flex" href="#什么是-B-Tree-索引？-1"><span class="mr-2">2.3.2</span><span>什么是 B+Tree 索引？</span></a></li><li><a class="is-flex" href="#什么是-hash-索引？"><span class="mr-2">2.3.3</span><span>什么是 hash 索引？</span></a></li></ul></li><li><a class="is-flex" href="#聚集索引与非聚集索引"><span class="mr-2">2.4</span><span>聚集索引与非聚集索引</span></a></li><li><a class="is-flex" href="#MyISAM-索引与-InnoDB-索引的区别？"><span class="mr-2">2.5</span><span>MyISAM 索引与 InnoDB 索引的区别？</span></a></li><li><a class="is-flex" href="#如何定位并优化慢查询的-Sql"><span class="mr-2">2.6</span><span>如何定位并优化慢查询的 Sql</span></a><ul class="menu-list"><li><a class="is-flex" href="#定位慢查询sql"><span class="mr-2">2.6.1</span><span>定位慢查询sql</span></a></li><li><a class="is-flex" href="#Explian-关键字"><span class="mr-2">2.6.2</span><span>Explian 关键字</span></a></li></ul></li><li><a class="is-flex" href="#联合索引的最左匹配原则的成因"><span class="mr-2">2.7</span><span>联合索引的最左匹配原则的成因</span></a></li><li><a class="is-flex" href="#索引是建立得越多越好的吗"><span class="mr-2">2.8</span><span>索引是建立得越多越好的吗</span></a></li></ul></li><li><a class="is-flex" href="#锁模块"><span class="mr-2">3</span><span>锁模块</span></a><ul class="menu-list"><li><a class="is-flex" href="#常见问题"><span class="mr-2">3.1</span><span>常见问题</span></a></li><li><a class="is-flex" href="#MyISAM-与-InnoDB-关于锁方面的区别是什么"><span class="mr-2">3.2</span><span>MyISAM 与 InnoDB 关于锁方面的区别是什么</span></a></li><li><a class="is-flex" href="#数据库锁的分类"><span class="mr-2">3.3</span><span>数据库锁的分类</span></a></li><li><a class="is-flex" href="#ACID"><span class="mr-2">3.4</span><span>ACID</span></a><ul class="menu-list"><li><a class="is-flex" href="#1-原子性（Atomicity）"><span class="mr-2">3.4.1</span><span>1. 原子性（Atomicity）</span></a></li><li><a class="is-flex" href="#2-一致性（Consistency）"><span class="mr-2">3.4.2</span><span>2. 一致性（Consistency）</span></a></li><li><a class="is-flex" href="#3-隔离性（Isolation）"><span class="mr-2">3.4.3</span><span>3. 隔离性（Isolation）</span></a></li><li><a class="is-flex" href="#4-持久性（Durability）"><span class="mr-2">3.4.4</span><span>4. 持久性（Durability）</span></a></li></ul></li><li><a class="is-flex" href="#并发一致性问题"><span class="mr-2">3.5</span><span>并发一致性问题</span></a><ul class="menu-list"><li><a class="is-flex" href="#丢失修改"><span class="mr-2">3.5.1</span><span>丢失修改</span></a></li><li><a class="is-flex" href="#读脏数据"><span class="mr-2">3.5.2</span><span>读脏数据</span></a></li><li><a class="is-flex" href="#不可重复读"><span class="mr-2">3.5.3</span><span>不可重复读</span></a></li><li><a class="is-flex" href="#幻影读"><span class="mr-2">3.5.4</span><span>幻影读</span></a></li></ul></li><li><a class="is-flex" href="#隔离级别"><span class="mr-2">3.6</span><span>隔离级别</span></a><ul class="menu-list"><li><a class="is-flex" href="#未提交读（READ-UNCOMMITTED）"><span class="mr-2">3.6.1</span><span>未提交读（READ UNCOMMITTED）</span></a></li><li><a class="is-flex" href="#提交读（READ-COMMITTED）"><span class="mr-2">3.6.2</span><span>提交读（READ COMMITTED）</span></a></li><li><a class="is-flex" href="#可重复读（REPEATABLE-READ）"><span class="mr-2">3.6.3</span><span>可重复读（REPEATABLE READ）</span></a></li><li><a class="is-flex" href="#可串行化（SERIALIZABLE）"><span class="mr-2">3.6.4</span><span>可串行化（SERIALIZABLE）</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#参考链接"><span class="mr-2">4</span><span>参考链接</span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://blog.cuzz.site',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>