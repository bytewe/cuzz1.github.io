<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Redis - Hexo</title><meta description="博客记录"><meta property="og:type" content="blog"><meta property="og:title" content="Redis"><meta property="og:url" content="http://blog.cuzz.site/2019/02/23/Redis/"><meta property="og:site_name" content="cuzz&#039;s blog"><meta property="og:description" content="博客记录"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://blog.cuzz.site/2019/02/23/Redis/Redis%5C01.png"><meta property="og:image" content="http://blog.cuzz.site/2019/02/23/Redis/Redis%5C388326-20170726161552843-904424952.png"><meta property="og:image" content="http://blog.cuzz.site/2019/02/23/Redis/Redis%5C388326-20170726161604968-371688235.png"><meta property="og:image" content="http://blog.cuzz.site/2019/02/23/Redis/Redis%5Ctimg.jpg"><meta property="article:published_time" content="2019-02-23T15:59:59.000Z"><meta property="article:modified_time" content="2020-08-21T12:42:19.198Z"><meta property="article:author" content="cuzz"><meta property="article:tag" content="转载"><meta property="article:tag" content="Redis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="Redis%5C01.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.cuzz.site/2019/02/23/Redis/"},"headline":"Hexo","image":["http://blog.cuzz.site/2019/02/23/Redis/Redis%5C01.png","http://blog.cuzz.site/2019/02/23/Redis/Redis%5C388326-20170726161552843-904424952.png","http://blog.cuzz.site/2019/02/23/Redis/Redis%5C388326-20170726161604968-371688235.png","http://blog.cuzz.site/2019/02/23/Redis/Redis%5Ctimg.jpg"],"datePublished":"2019-02-23T15:59:59.000Z","dateModified":"2020-08-21T12:42:19.198Z","author":{"@type":"Person","name":"John Doe"},"description":"什么是 Redis ？Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。 另外，Redis 已经成为互联网公司在缓存组件选择的唯一，更多的关注点是，如何使用好 Redis 。"}</script><link rel="canonical" href="http://blog.cuzz.site/2019/02/23/Redis/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.0.2"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Hexo" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/cuzz1"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-02-23T15:59:59.000Z" title="2019-02-23T15:59:59.000Z">2019-02-23</time><span class="level-item"><a class="link-muted" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="level-item">an hour read (About 12900 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Redis</h1><div class="content"><h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p>Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。</p>
<p>另外，Redis 已经成为互联网公司在缓存组件选择的唯一，更多的关注点是，如何使用好 Redis 。</p>
<a id="more"></a>

<h3 id="Redis-有什么优点？"><a href="#Redis-有什么优点？" class="headerlink" title="Redis 有什么优点？"></a>Redis 有什么优点？</h3><p><strong>1、速度快</strong></p>
<p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p>
<blockquote>
<p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p>
</blockquote>
<ul>
<li>如果我们查看在<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/26350.html">阿里云销售的 Redis 规格</a>，最低的也是 8W QPS 。</li>
</ul>
<p><strong>2、支持丰富数据类型</strong></p>
<p>支持 String ，List，Set，Sorted Set，Hash 。</p>
<blockquote>
<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 Value 的最大限制是1GB，不像 Memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说：</p>
<ul>
<li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li>
<li>用他的 Set 可以做高性能的 tag 系统等等。</li>
</ul>
</blockquote>
<p><strong>3、丰富的特性</strong></p>
<ul>
<li>订阅发布 Pub / Sub 功能</li>
<li>Key 过期策略</li>
<li>事务</li>
<li>支持多个 DB</li>
<li>计数</li>
<li>…</li>
</ul>
<p>并且在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<p><strong>4、持久化存储</strong></p>
<p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p>
<h3 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h3><ul>
<li><p>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<blockquote>
<p>另外，可使用 Redis Cluster、Codis 等方案，对 Redis 进行分区，从单机 Redis 变成集群 Redis 。</p>
</blockquote>
</li>
<li><p>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</p>
</li>
<li><p>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</p>
</li>
</ul>
<h2 id="Redis-和-Memcached-的区别有哪些？"><a href="#Redis-和-Memcached-的区别有哪些？" class="headerlink" title="Redis 和 Memcached 的区别有哪些？"></a>Redis 和 Memcached 的区别有哪些？</h2><p><strong>1、Redis 支持复杂的数据结构</strong></p>
<ul>
<li>Memcached 仅提供简单的字符串。</li>
<li>Redis 提供复杂的数据结构，丰富的数据操作。</li>
</ul>
<p>也因为 Redis 支持复杂的数据结构，Redis 即使往于 Memcached 推出，却获得更多开发者的青睐。</p>
<p>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作，Redis 会是不错的选择。</p>
<p><strong>2、Redis 原生支持集群模式</strong></p>
<ul>
<li>在 Redis3.x 版本中，官方便能支持 Cluster 模式。</li>
<li>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li>
</ul>
<p><strong>3、性能对比</strong></p>
<ul>
<li>Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis在存储小数据时比 Memcached 性能更高。</li>
<li>在 100k 以上的数据中，Memcached 性能要高于 Redis 。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li>
</ul>
<p>更多关于性能的对比，可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/34f90813d7c9">《Memcached 与 Redis 的关键性能指标比较》</a> 。</p>
<p><strong>4、内存使用效率对比</strong></p>
<ul>
<li><p>简单的 Key-Value 存储的话，Memcached 的内存利用率更高，可以使用类似内存池。</p>
</li>
<li><p>如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩， 其内存利用率会高于 Memcached 。</p>
</li>
<li><p>Redis 和 Memcached 的内存管理方法不同，Redis 采用的是包装的 malloc/free ， 相较于 Memcached 的内存管理方法 tcmalloc / jmalloc 来说，要简单很多 。</p>
</li>
</ul>
<p><strong>5、网络 IO 模型</strong></p>
<ul>
<li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li>
<li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select ，更接近 Apache 早期的模式。</li>
</ul>
<p>TODO 有点看不懂，找亚普表弟确认中。</p>
<p><strong>6、持久化存储</strong></p>
<ul>
<li>Memcached 不支持持久化存储，重启时，数据被清空。</li>
<li>Redis 支持持久化存储，重启时，可以恢复已持久化的数据。</li>
</ul>
<p>也推荐阅读下 <a target="_blank" rel="noopener" href="https://www.imooc.com/article/23549">《脚踏两只船的困惑 - Memcached 与 Redis》</a> 。</p>
<h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><blockquote>
<p>艿艿：这个是我从网络上找的资料，讲的灰常不错。</p>
</blockquote>
<p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p>来看客户端与 redis 的一次通信过程：</p>
<p><img src="Redis%5C01.png" alt="redis-single-thread-model"></p>
<ul>
<li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li>
<li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li>
<li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li>
</ul>
<p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。如果还是不能理解，可以在网络上搜一些资料，在理解理解。</p>
<h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul>
<li><p>1、纯内存操作。</p>
<blockquote>
<p>Redis 为了达到最快的读写速度，将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。</p>
<p>如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。</p>
</blockquote>
</li>
<li><p>2、核心是基于非阻塞的 IO 多路复用机制。</p>
</li>
<li><p>3、单线程反而避免了多线程的频繁上下文切换问题。</p>
<blockquote>
<p>Redis 利用队列技术，将并发访问变为串行访问，消除了传统数据库串行控制的开销</p>
</blockquote>
</li>
<li><p>4、Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p>
</li>
</ul>
<h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p>
<ul>
<li>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><img src="Redis%5C388326-20170726161552843-904424952.png" alt="img"></p>
<p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<p><img src="Redis%5C388326-20170726161604968-371688235.png" alt="img"></p>
<h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p><strong>RDB存在哪些优势呢？</strong></p>
<ul>
<li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li>
<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li>
<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>
</ul>
<p><strong>RDB又存在哪些劣势呢？</strong></p>
<ul>
<li>.如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ul>
<p><strong>AOF的优势有哪些呢？</strong></p>
<ul>
<li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li>
<li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li>
<li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li>
</ul>
<p><strong>AOF的劣势有哪些呢？</strong></p>
<ul>
<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li>
</ul>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent 的意思了。</p>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><strong>RDB持久化配置</strong></p>
<p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1         # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</span><br><span class="line">save 300 10        # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</span><br><span class="line">save 60 10000      # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure>

<p><strong>AOF持久化配置</strong></p>
<p>在Redis的配置文件中存在三种同步方式，它们分别是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always     # 每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no         # 从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure>

<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul>
<li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据</p>
</li>
<li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p>
</li>
<li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<ul>
<li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p>
<blockquote>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>在 Redis4.0 版本开始，允许你使用 RDB-AOF 混合持久化方式，详细可见 <a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/193034">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。也因此，RDB 和 AOF 同时使用，是希望达到安全的持久化的推荐方式。</p>
<h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><ul>
<li>根据 redis.conf 配置中 SAVE m n 定时触发（使用的BGSAVE）</li>
<li>主从复制时，主节点自动触发</li>
<li>执行 Debug Reload</li>
<li>执行 Shutdown 且没有开启 AOF 持久化</li>
</ul>
<p>BGSAVE 原理：</p>
<p><img src="Redis%5Ctimg.jpg" alt="timg"></p>
<p><strong>重要知识：</strong></p>
<ul>
<li>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</li>
<li>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。</li>
<li>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li>
</ul>
<h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p>
<p>Redis 提供了 3 种数据过期策略：</p>
<ul>
<li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li>
<li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Redis/Interview/#">「数据“淘汰”策略」</a> 。</li>
</ul>
<p>在 Redis 中，同时使用了上述 3 种策略，即它们<strong>非互斥</strong>的。</p>
<p>想要进一步了解，可以看看 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenpingzhao/p/5022467.html">《关于 Redis 数据过期策略》</a> 文章。</p>
<h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p>
<p>Redis 提供了 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru</li>
<li>volatile-ttl</li>
<li>volatile-random</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>no-enviction</li>
</ol>
<p>具体的 <strong>每种数据淘汰策略的定义</strong>，和 <strong>如何选择讨论策略</strong>，可见 <a target="_blank" rel="noopener" href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/">《Redis实战（二） 内存淘汰机制》</a> 。</p>
<p> <strong>Redis LRU 算法</strong></p>
<p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p>
<ul>
<li><p>具体的可以看看 <a target="_blank" rel="noopener" href="http://ifeve.com/lru-cache/">《使用 Redis 作为一个 LRU 缓存》</a> 文章。</p>
<p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p>
</li>
</ul>
<blockquote>
<p>艿艿：这个是从网络上找到的一个神奇的问题，并且看了答案之后，觉得有点莫名的对不上。</p>
<p>所以，感觉这个问题的目的是，如何保证热点数据不要被淘汰。</p>
</blockquote>
<p>在 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Redis/Interview/#">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。” 。</p>
<p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p>
<p>相比较来说，最终会选择 allkeys-lru 淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略。</p>
<p> <strong>Redis 回收进程如何工作的？</strong></p>
<p>理解回收进程如何工作是非常重要的：</p>
<ul>
<li>一个客户端运行了新的命令，添加了新的数据</li>
<li>Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li>
<li>Redis 执行新命令……</li>
</ul>
<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下（跌宕起伏）。</p>
<h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p>
<p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h2 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h2><p>如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：</p>
<ul>
<li>字符串 String</li>
<li>字典Hash</li>
<li>列表List</li>
<li>集合Set</li>
<li>有序集合 SortedSet</li>
</ul>
<p>如果你是 Redis 中级玩家，还需要加上下面几种数据结构：</p>
<ul>
<li>HyperLogLog</li>
<li>Geo</li>
<li>Pub / Sub</li>
</ul>
<p>如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：</p>
<ul>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
<li>JSON</li>
</ul>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。😈 默默跟面试官在装一波。</p>
<h2 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a>聊聊 Redis 使用场景</h2><p>Redis 可用的场景非常之多：</p>
<ul>
<li>数据缓存</li>
<li>会话缓存</li>
<li>时效性数据</li>
<li>访问频率</li>
<li>计数器</li>
<li>社交列表</li>
<li>记录用户判定信息</li>
<li>交集、并集和差集</li>
<li>热门列表与排行榜</li>
<li>最新动态</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<p>详细的介绍，可以看看如下文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://blog.720ui.com/2017/redis_core_use/">《聊聊 Redis 使用场景》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/af277c77b1c9">《Redis 应用场景及实例》</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29665317">《Redis 常见的应用场景解析》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19829601">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li>
</ul>
<p><strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p>
<p>用列表实现，列表中每个元素代表登陆时间，只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆。</p>
<p>具体的代码实现，可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e3abbfc59d77">《一道 Redis 面试题》</a> 。</p>
<h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p>
<ul>
<li><p>Redisson</p>
<blockquote>
<p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
</blockquote>
</li>
<li><p>Jedis</p>
<blockquote>
<p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p>
<p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p>
<p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</blockquote>
</li>
<li><p>Lettuce</p>
<blockquote>
<p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p>
</blockquote>
</li>
</ul>
<p>Redis 官方推荐使用 Redisson 或 Jedis 。</p>
<p>Spring Boot 2.x 内置使用 Lettuce 。</p>
<h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p> <strong>方案一：set 指令</strong></p>
<p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<ul>
<li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li>
<li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li>
</ul>
<p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li>
<li>具体的实现，可以参考 <a target="_blank" rel="noopener" href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/">《Redis 分布式锁的正确实现方式（Java版）》</a> 文章。</li>
</ul>
<p><strong>方案二：redlock</strong></p>
<p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p>
<p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ">《Redlock：Redis分布式锁最牛逼的实现》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f302aa345ca8">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li>
</ul>
<p> <strong>对比 Zookeeper 分布式锁</strong></p>
<ul>
<li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li>
<li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li>
</ul>
<p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。</p>
<h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<ul>
<li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li>
<li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li>
<li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li>
<li>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li>
</ul>
<p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>Redis 很早就支持管道（<a target="_blank" rel="noopener" href="http://redis.cn/topics/pipelining.html">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p>
<p> <strong>Redis 如何做大量数据插入？</strong></p>
<p>Redis2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>
<p>具体可见 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/mass-insert.html">《Redis 大量数据插入》</a> 文章。</p>
<h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在Redis中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：</p>
<ul>
<li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p>
</li>
<li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p>
</li>
<li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令都，将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p>
</li>
<li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p>
</li>
<li><p>5、当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p>
<blockquote>
<p>Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p>
</blockquote>
</li>
</ul>
<p><strong>如何实现 Redis CAS 操作？</strong></p>
<p>在 Redis 的事务中，WATCH 命令可用于提供CAS(check-and-set)功能。</p>
<p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p>
<p>具体的示例，可以看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0244a875aa26">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p>
<h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p>
<ul>
<li>1、Redis Sentinel</li>
<li>2、Redis Cluster</li>
<li>3、Twemproxy</li>
<li>4、Codis</li>
<li>5、客户端分片</li>
</ul>
<p>关于前四种，可以看看 <a target="_blank" rel="noopener" href="http://blog.720ui.com/2016/redis_action_04_cluster/">《Redis 实战（四）集群机制》</a> 这篇文章。</p>
<p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p>
<blockquote>
<p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p>
<p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
</blockquote>
<p><strong>选择</strong></p>
<p>目前一般在选型上来说：</p>
<ul>
<li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p>
</li>
<li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p>
<p><strong>Redis 集群如何扩容？</strong></p>
</li>
</ul>
<blockquote>
<p>这个问题，艿艿了解的也不是很多，建议在搜索有什么方案。</p>
</blockquote>
<ul>
<li>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</li>
<li>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</li>
</ul>
<h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p>
<p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p>
<ul>
<li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li>
<li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li>
<li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
<p><strong>好处</strong></p>
<p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
<p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p>
<p>更多详细，可以看看 <a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md">《Redis 主从架构》</a> 。</p>
<h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>可以看看 <a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md">《Redis 哨兵集群实现高可用》</a> 。</p>
<h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>可以看看</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://redis.cn/topics/cluster-tutorial.html">《Redis 集群教程》</a> 完整版</li>
<li><a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md">《Redis 集群模式的工作原理能说一下么？》</a> 精简版</li>
</ul>
<p><strong>说说 Redis 哈希槽的概念？</strong></p>
<p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p>
<p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p>
<p> <strong>Redis Cluster 的主从复制模型是怎样的？</strong></p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p>
<p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p>
<ul>
<li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li>
<li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用Cluster 进行分片存储。</li>
</ul>
<p><strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p>
<p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p>
<p> <strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p>
<p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<p><strong>Redis 集群如何选择数据库？</strong></p>
<p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>
<p><strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p>
<blockquote>
<p>重点问题，仔细理解。</p>
</blockquote>
<ul>
<li>Redis Cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li>
<li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。那么，5 台机器对外提供读写，一共有 50g 内存。</li>
<li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li>
<li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1g 。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li>
<li>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</li>
</ul>
<h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote>
<p>这个问题，和 <a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Redis/Interview/#">「Redis 集群都有哪些方案？」</a> 是同类问题。</p>
</blockquote>
<p> 关于如下四个问题，直接看 <a target="_blank" rel="noopener" href="http://www.runoob.com/redis/redis-partitioning.html">《Redis 分区》</a> 文章。</p>
<ul>
<li>Redis 分区是什么？</li>
<li>分区的优势？</li>
<li>分区的不足？</li>
<li>分区类型？</li>
</ul>
<p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p>
<ul>
<li>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</li>
<li>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</li>
</ul>
<p><strong>你知道有哪些 Redis 分区实现方案</strong>？</p>
<p>Redis 分区方案，主要分成两种类型：</p>
<ul>
<li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul>
<li>案例：Redis Cluster 和客户端分区。</li>
</ul>
</li>
<li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。 <ul>
<li>案例：Twemproxy 和 Codis 。</li>
</ul>
</li>
</ul>
<p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirect 到正确的 Redis 节点。</p>
<p><strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p>
<p>如下是网络上的一个大答案：</p>
<blockquote>
<p>既然 Redis 是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
</blockquote>
<ul>
<li>和飞哥沟通了下，这个操作不是很合理。</li>
<li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster 集群</li>
</ul>
<h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA">《Redis 几个重要的健康指标》</a></p>
<ul>
<li>存活情况</li>
<li>连接数</li>
<li>阻塞客户端数量</li>
<li>使用内存峰值</li>
<li>内存碎片率</li>
<li>缓存命中率</li>
<li>OPS</li>
<li>持久化</li>
<li>失效KEY</li>
<li>慢日志</li>
</ul>
<p><strong>如何提高 Redis 命中率？</strong></p>
<p>推荐阅读 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/shamo89/p/8383915.html">《如何提高缓存命中率（Redis）》</a> 。</p>
<h2 id="怎么优化-Redis-的内存占用"><a href="#怎么优化-Redis-的内存占用" class="headerlink" title="怎么优化 Redis 的内存占用"></a>怎么优化 Redis 的内存占用</h2><p>推荐阅读 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8677603d3865">《Redis 的内存优化》</a></p>
<ul>
<li><p>redisObject 对象</p>
</li>
<li><p>缩减键值对象</p>
</li>
<li><p>共享对象池</p>
</li>
<li><p>字符串优化</p>
</li>
<li><p>编码优化</p>
</li>
<li><p>控制 key 的数量</p>
<p><strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p>
</li>
</ul>
<p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p>
<p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p>
<p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p>
<p><strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p>
<p>使用 keys 指令可以扫出指定模式的 key 列表。</p>
<ul>
<li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用keys指令会有什么问题？</li>
<li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li>
</ul>
<h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><p><strong>1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</strong></p>
<ul>
<li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li>
<li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li>
<li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次</li>
</ul>
<p><strong>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</strong> </p>
<p><strong>3、尽量避免在压力很大的主库上增加从库。</strong> </p>
<p><strong>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</strong> </p>
<ul>
<li>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</li>
</ul>
<p><strong>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</strong></p>
<hr>
<p>和飞哥沟通过后，他们主节点开启 AOF ，从节点开启 AOF + RDB 。</p>
<p>和晓峰沟通后，他们主节点开启 AOF ，从节点开启 RDB 居多，也有开启 AOF + RDB 的。</p>
<h2 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h2><p>针对运行实例，有许多配置选项可以通过 <code>CONFIG SET</code> 命令进行修改，而无需执行任何形式的重启。</p>
<p>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 <code>CONFIG GET *</code> 命令获取更多信息。</p>
<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些比较凶残的面试官，可能会问我们一些 Redis 数据结构的问题，例如：</p>
<ul>
<li><p>Skiplist 插入和查询原理？</p>
</li>
<li><p>压缩列表的原理？</p>
</li>
<li><p>Redis 底层为什么使用跳跃表而不是红黑树？</p>
<blockquote>
<p>跳跃表在范围查找的时候性能比较高。</p>
</blockquote>
</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="http://svip.iocoder.cn/Redis/Interview/">精尽 Redis 面试题 </a></li>
</ul>
</div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a><a class="link-muted mr-2" rel="tag" href="/tags/Redis/">Redis</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechatpay.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/02/23/Java%E5%90%8E%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java后端核心知识</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-item">数据库</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: 'a74a68934e87d92a7068259967d1bbbb',
            repo: 'cuzz1.github.io',
            owner: 'cuzz1',
            clientID: 'e829281603f9115c572d',
            clientSecret: '246dae10dfb1b363805ab98902dc93539c355bb3',
            admin: ["cuzz1"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: 'last',
            
            
            enableHotKey: true
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#什么是-Redis-？"><span class="mr-2">1</span><span>什么是 Redis ？</span></a><ul class="menu-list"><li><a class="is-flex" href="#Redis-有什么优点？"><span class="mr-2">1.1</span><span>Redis 有什么优点？</span></a></li><li><a class="is-flex" href="#Redis-有什么缺点？"><span class="mr-2">1.2</span><span>Redis 有什么缺点？</span></a></li></ul></li><li><a class="is-flex" href="#Redis-和-Memcached-的区别有哪些？"><span class="mr-2">2</span><span>Redis 和 Memcached 的区别有哪些？</span></a></li><li><a class="is-flex" href="#请说说-Redis-的线程模型？"><span class="mr-2">3</span><span>请说说 Redis 的线程模型？</span></a></li><li><a class="is-flex" href="#为什么-Redis-单线程模型也能效率这么高？"><span class="mr-2">4</span><span>为什么 Redis 单线程模型也能效率这么高？</span></a></li><li><a class="is-flex" href="#Redis-有几种持久化方式？"><span class="mr-2">5</span><span>Redis 有几种持久化方式？</span></a><ul class="menu-list"><li><a class="is-flex" href="#持久化方式"><span class="mr-2">5.1</span><span>持久化方式</span></a></li><li><a class="is-flex" href="#二者的区别"><span class="mr-2">5.2</span><span>二者的区别</span></a></li><li><a class="is-flex" href="#二者优缺点"><span class="mr-2">5.3</span><span>二者优缺点</span></a></li><li><a class="is-flex" href="#常用配置"><span class="mr-2">5.4</span><span>常用配置</span></a></li><li><a class="is-flex" href="#如何选择"><span class="mr-2">5.5</span><span>如何选择</span></a></li><li><a class="is-flex" href="#自动化触发-RDB-持久化的方式"><span class="mr-2">5.6</span><span>自动化触发 RDB 持久化的方式</span></a></li></ul></li><li><a class="is-flex" href="#Redis-有几种数据“过期”策略？"><span class="mr-2">6</span><span>Redis 有几种数据“过期”策略？</span></a></li><li><a class="is-flex" href="#Redis-有哪几种数据“淘汰”策略？"><span class="mr-2">7</span><span>Redis 有哪几种数据“淘汰”策略？</span></a></li><li><a class="is-flex" href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><span class="mr-2">8</span><span>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</span></a></li><li><a class="is-flex" href="#Redis-有哪些数据结构？"><span class="mr-2">9</span><span>Redis 有哪些数据结构？</span></a></li><li><a class="is-flex" href="#聊聊-Redis-使用场景"><span class="mr-2">10</span><span>聊聊 Redis 使用场景</span></a></li><li><a class="is-flex" href="#Redis-支持的-Java-客户端都有哪些？"><span class="mr-2">11</span><span>Redis 支持的 Java 客户端都有哪些？</span></a></li><li><a class="is-flex" href="#如何使用-Redis-实现分布式锁？"><span class="mr-2">12</span><span>如何使用 Redis 实现分布式锁？</span></a></li><li><a class="is-flex" href="#如何使用-Redis-实现消息队列？"><span class="mr-2">13</span><span>如何使用 Redis 实现消息队列？</span></a></li><li><a class="is-flex" href="#什么是-Redis-Pipelining-？"><span class="mr-2">14</span><span>什么是 Redis Pipelining ？</span></a></li><li><a class="is-flex" href="#什么是-Redis-事务？"><span class="mr-2">15</span><span>什么是 Redis 事务？</span></a></li><li><a class="is-flex" href="#Redis-集群都有哪些方案？"><span class="mr-2">16</span><span>Redis 集群都有哪些方案？</span></a></li><li><a class="is-flex" href="#什么是-Redis-主从同步？"><span class="mr-2">17</span><span>什么是 Redis 主从同步？</span></a></li><li><a class="is-flex" href="#如何使用-Redis-Sentinel-实现高可用？"><span class="mr-2">18</span><span>如何使用 Redis Sentinel 实现高可用？</span></a></li><li><a class="is-flex" href="#如果使用-Redis-Cluster-实现高可用？"><span class="mr-2">19</span><span>如果使用 Redis Cluster 实现高可用？</span></a></li><li><a class="is-flex" href="#什么是-Redis-分区？"><span class="mr-2">20</span><span>什么是 Redis 分区？</span></a></li><li><a class="is-flex" href="#Redis-有哪些重要的健康指标？"><span class="mr-2">21</span><span>Redis 有哪些重要的健康指标？</span></a></li><li><a class="is-flex" href="#怎么优化-Redis-的内存占用"><span class="mr-2">22</span><span>怎么优化 Redis 的内存占用</span></a></li><li><a class="is-flex" href="#Redis-常见的性能问题都有哪些？如何解决？"><span class="mr-2">23</span><span>Redis 常见的性能问题都有哪些？如何解决？</span></a></li><li><a class="is-flex" href="#修改配置不重启-Redis-会实时生效吗？"><span class="mr-2">24</span><span>修改配置不重启 Redis 会实时生效吗？</span></a></li><li><a class="is-flex" href="#其他问题"><span class="mr-2">25</span><span>其他问题</span></a></li><li><a class="is-flex" href="#参考链接"><span class="mr-2">26</span><span>参考链接</span></a></li></ul></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Hexo" height="28"></a><p class="size-small"><span>&copy; 2020 John Doe</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://blog.cuzz.site',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>